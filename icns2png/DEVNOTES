===============================================================================
Developers notes for libicns 0.3.0a - February 15th, 2008
Copyright (C) 2001-2008 Mathew Eis <mathew@eisbox.net>

===============================================================================
Section I:  (For those wishing to use libicns)
  Structures
  Functions
  Example
Section II: (For those wishing to contribute to libicns)
  Versioning Notes
  Naming Conventions
  Endianness issues
  icns data format
===============================================================================
Section I
===============================================================================
Structures
typedef struct icns_element_t
typedef struct icns_family_t
typedef struct icns_image_t
Note about the data in icns_image_t - if the bit-depth is less than 8 bits, the
data will be a squashed stream. i.e. for 1 bit data, one byte is actually 8
pixels, that is, 11111111, for 4 bit data, one byte is two pixels, 0xF 0xF
In 32-bit data, the data stream is in ARGB order by default
In addition, the 4 and 8 byte images are encoded using the palettes found in
the file colormaps.h
See icns.h for more information
===============================================================================
Functions

-------------------------------------------------------------------------------
Note: The functions defined as *external* are guaranteed to be binary compatible
with libicns through version 0.2.0, probably later, unless a major bug
requires it to be changed.
-------------------------------------------------------------------------------


-------------------------------------------------------------------------------
icns_get_mask_type_for_icon_type *external*
- Retreives the mask type that should be associated with a given icon type

icns_get_image32_with_mask_from_family *external*
- Retreives an icon image from an icns family. Additionally retrieves the mask
- and loads it to the alpha channel. This function would be slightly faster than
- loading the icon and mask as seperate 32-bit images. Data is returned by
- reference in an icns image object with 32-bit raw, decoded, uncompressed data

-------------------------------------------------------------------------------
icns_get_image32_from_element *external*
- Retreives an icon image from an icns element. Data is returned by
- reference in an icns image object with 32-bit raw, decoded, uncompressed data

-------------------------------------------------------------------------------
icns_get_image_from_element *external*
- Retreives an icon image from an icns element. Data is returned by
- reference in an icns image object with raw, decoded, uncompressed data.
- However, if the bytes are packed, they will stay that way. The 'image32'
- functions above will both unpack the bytes first.

-------------------------------------------------------------------------------
icns_decode_rle24_data *internal*
- Decodes rgb run-length-encoded data into a 24-bit rgb data stream (stored in
  32-bit argb format, the alpha is simply ignored.

-------------------------------------------------------------------------------
icns_encode_rle24_data *internal*
- Encodes an argb data stream into a 24-bit rgb run-length-encoded data stream
- note that the alhpa channel is ignored

-------------------------------------------------------------------------------
icns_init_image_for_type *external*
- Initializes an icns image using the type for the parameters

-------------------------------------------------------------------------------
icns_init_image *external*
- Initializes an icns image using given parameters

-------------------------------------------------------------------------------
icns_free_image *external*
- Deallocates the memory used by an icns_image structure

-------------------------------------------------------------------------------
icns_opj_error_callback *internal*
- Error callback for the openjpeg library routines. For internal use only

-------------------------------------------------------------------------------
icns_opj_warning_callback *internal*
- Warning callback for the openjpeg library routines. For internal use only

-------------------------------------------------------------------------------
icns_opj_info_callback *internal*
- Info callback for the openjpeg library routines. For internal use only

-------------------------------------------------------------------------------
icns_opj_to_image *internal*
- Converts jpeg2000 data to a 32-bit icns_image

-------------------------------------------------------------------------------
jp2dec *internal*
- Decompresses jpeg2000 data

-------------------------------------------------------------------------------
icns_new_element_from_image *external*
- Creates an icns element structure from an icns image

-------------------------------------------------------------------------------
icns_get_element_from_family *external*
- Retreives an icns element of the requested type from an icns family

-------------------------------------------------------------------------------
icns_set_element_in_family *external*
- Adds/updates an icns element of it's type in an icns family

-------------------------------------------------------------------------------
icns_remove_element_in_family *external*
- Removes an icns element of the requested type from an icns family

-------------------------------------------------------------------------------
icns_create_family *external*
- Creates a new icns family

-------------------------------------------------------------------------------
icns_write_family_to_file *external*

-------------------------------------------------------------------------------
icns_read_family_from_file *external*

-------------------------------------------------------------------------------
icns_family_from_file_data *internal*
- Retreives an icns family from a file. Note that if the file is in raw icns
- format, this essentially means copying the file data to a location in
- memory. Many icns files, however, are stored as rsrc files, do more decoding
- is usually necessary

-------------------------------------------------------------------------------
icns_family_from_mac_resource *internal*
- Primarily for internal use. Parses a Macintosh rsrc data set and retrieves
- the first 'icns' resource found. Note that it is technically possible for
- there to be more than one resource of type 'icns'.

-------------------------------------------------------------------------------
icns_parse_macbinary_resource_fork *internal*
- Again primarily for internal use. Parses MacBinary data into Macintosh
- rsrc data. Some icns files are stored within macbinary encoded rsrc files
See icns.h for reference on the actual parameters used in these functions.

===============================================================================
Version information
versions are in the format of: 0.0.0a (MAJOR.MINOR.RELEASE[dev])

Development changes should increment the letter with each commit
Releases should increment the middle number and remove the letter
Milestone releases should increment the middle number and remove the letter
  -- beta relases should be odd numbered
  -- stable releases should be even numbered
Major number should increment only for file format changes causing breakage
to a previously stable version, or on the decision of two or more developers
Examples, in descending order:
0.1.1  - beta version 0 milestone 1 release 1 official
0.1.1a - beta version 0 milestone 1 release candidate 1 dev a 
0.1.1  - beta version 0 milestone 1 release candidate 1 dev b
0.1.2  - beta version 0 milestone 1 release 2 official
0.2.0  - stable version 0 milestone 1 release 0 official

===============================================================================
Naming conventions

Where possible, the naming conventions are to be similar in manner to the
libpng library. libpng has been around for a long time, it's naming conventions
are mature, and developers are well aquanted with them.

===============================================================================
Endianness issues

The 'icns' icon family type has been in existence since the Mac 68k. The data
stored within the files is, therefore, big-endian native. From experience, it
seems unclear whether we are guaranteed this to be the case.
The current definitive documentation on the issue seems to be found in the
Apple Developer Connection document "Guidelines for Swapping Bytes" from
"Universal Binary Programming Guidelines Second Edition" - see as follows:
-------------------------------------------------------------------------------
Be aware of which functions return big-endian data, and use them appropriately.
These include the BSD Sockets networking functions, the DNSServiceDiscovery
functions (for example, TCP and UDP ports are specified in network byte order),
and the ColorSync profile functions (for which all data is big-endian). The
IconFamilyElement and IconFamilyResource data types (which also include the
data types IconFamilyPtr and IconFamilyHandle) are always big-endian. There
may be other functions and data types that are not listed here. Consult the
appropriate API reference for information on data returned by a function. For
more information see 
Network-Related Data.
-------------------------------------------------------------------------------
Source: http://developer.apple.com/documentation/MacOSX/Conceptual/
universal_binary/universal_binary_byte_swap/chapter_4_section_3.html

Since Apple's own Developer Documentation indicates icns is ALWAYS big-endian
libicns assumes that all data will be in the big endian format, and therefore
assumes any data that is not big endian to be corrupt. Perhaps at some point
in the future it could add support for recovering an improperly written file.

===============================================================================
icns data format is basically an 8-byte header, followed by icns elements
---- 8 byte header ----
+4 byte type id, always 'icns'
+4 byte int - total size of icns data: equal to total icns size
---- icns_element objects ----
|---- 8 byte header ----
|+4 byte type id 'ICN#', 'icl8', etc...
|+4 byte int - total size of element data: equal to size of element
|==== raw, rle, or jp2 image data
|---- 8 byte header ----
|+4 byte type id 'ICN#', 'icl8', etc...
|+4 byte int - total size of image data: equal to size of element
|==== raw, rle, or jp2 image data
|EOF

===============================================================================
icns element is basically an 8-byte header, followed by icon data
+4 byte type id 'ICN#', 'icl8', etc...
+4 byte int - total size of icns data: equal to total element size
== data size equal to (elementSize - 8)

1-bit ich#, icm#, ics#, ICN#, icon notes 
- data is 8 pixels to a byte. 
- mask data follows the icon data
- example: data should be 256 bytes long for 32x32 icons
--- 128 bytes (32*32) / 8 for the icon data
--- 128 bytes (32*32) / 8 for the mask data

4-bit ich4, icm4, ics4, icl4, icon notes 
- data is 2 pixels to a byte, mask data is not part of the resource
- data is in 16 indexed colors, libicns provides the 32-bit colormap
- example: data should be 512 bytes long for 32x32 icons
--- 512 bytes (32*32) / 2 for the icon data

8-bit ich8, icm8, ics8, icl8, icon notes 
- data is 1 pixels to a byte, mask data is not part of the resource
- data is in 256 indexed colors, libicns provides the 32-bit colormap
- example: data should be 1024 bytes long for 32x32 icons
--- 1024 bytes (32*32) for the icon data

32-bit icon notes (size < 256x256) 
- data may or may not be RLE ecoded. Older icons never were, but newer
- icon editors seem to RLE encode even 16x16 32-bit icons. Mac OS seems
- to have no problem with this although only 128x128 icons were originally
- compressed using RLE.

32-bit icon notes (size >= 256x256) 
- data is jp2 encoded


==============================================================================
